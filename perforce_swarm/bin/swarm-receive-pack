#!/usr/bin/env ruby

require_relative '../init'

# we'll listen on a unix socket for the command "LOCK\n" from the pre-receive hook
# if invoked, we'll send back "LOCKED\n" post acquisition
# we only do this if we were passed the path to a valid repo with mirroring enabled
repo_path  = ARGV.length > 0 && File.realpath(ARGV.last) rescue false
mirror_url = repo_path && PerforceSwarm::Mirror.mirror_url(repo_path)
if repo_path && mirror_url
  lock_handle = nil # keeping the handle scoped outside the thread is important!
  lock_socket = "#{repo_path}/mirror_push-#{Process.pid}.socket"
  ENV['WRITE_LOCK_SOCKET'] = lock_socket
  File.unlink(lock_socket) if File.exist?(lock_socket)
  Thread.abort_on_exception = true
  thread = Thread.new do
    server = UNIXServer.new(lock_socket)
    socket = server.accept
    nil until socket.gets.chomp == 'LOCK'
    lock_handle = File.open("#{repo_path}/mirror_push.lock", 'w+', 0644)
    lock_handle.flock(File::LOCK_EX)
    socket.puts 'LOCKED'
    socket.flush
  end
end

# run the normal git-receive-pack giving it access to the lock socket
# note our abort_on_exception can result in spawn throwing; just eat those exceptions
Process.wait spawn(ENV, 'git-receive-pack', *ARGV) rescue
exit_code = $?.to_i

# ensure the thread is shutdown and cleanup our socket
if repo_path && mirror_url
  thread.kill
  File.unlink(lock_socket)
end

exit exit_code
